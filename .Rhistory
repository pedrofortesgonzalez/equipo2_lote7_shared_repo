head(eigenvalues) # ver caract. de primeras dimensiones
fviz_eig(pca.result, addlabels = TRUE)
fviz_pca_var(pca.result, col.var = "cos2", gradient.cols = c("blue","yellow", "red"), repel = TRUE, axes = c(1,2),
title = "Cos2 de variables en PC1 y PC2")
kmeans <- kmeans(t(df_genes), centers = 2)
clusters <- list()
for (i in 1:4) {
cluster.plot <- fviz_pca_var(
pca.result, col.var = kmeans$cluster, gradient.cols = c("blue","green", "red"),
axes = c(i,i+1), legend.title ="Clusterizacion", repel = TRUE)
clusters[[i]] <- cluster.plot
}
todos.clusters <- grid.arrange(grobs = clusters, nrow = 2)
todos.clusters
graficos <- list()
for (i in 1:5) {
grafico <- fviz_contrib(pca.result, choice ="var", axes = i, top = 5)
graficos[[i]] <- grafico
}
graficos_varianza <- grid.arrange(grobs = graficos, nrow = 3)
pca_loadings <- as.data.frame(pca.result$rotation) #los guardamos en un df
pca_loadings <- pca_loadings %>%
tibble::rownames_to_column(var="Gene") # gene names a columna (para no perderlos)
# los guardo en un objeto aparte para exportar con gt (ya que el formateo en scientific notation los conveirte en tipo chr.)
pca_loadings_exp <- pca_loadings %>% mutate(across(.cols = -Gene, # para toda cols excp Gene
~ ifelse(. < 0.1, sprintf("%.1e", .), sprintf("%.2f", .)))) # redondeamos a 1 decimal y escribimos en notación científica si son < 0.1, también con un decimal
# guardamos el df como objeto gt y exportamos para visualizar en Anexo
gtsave(gt(pca_loadings_exp), filename = "Tabla 2 - PCA Cargas.html") # guardar html
kmeans2 <- kmeans(df_genes, centers = 3)
fviz_cluster(kmeans2, df_genes)
fviz_pca_ind(pca.result, col.ind = "cos2", gradient.cols = c("blue","yellow", "red"), repel = TRUE)
df$metastasisnosi <- as.factor(ifelse( df$extension == "metastasico", "metastasis", "no_metastasis"))
df_pca_scores <- as.data.frame(pca.result$x)
df_pca_scores <- df_pca_scores[1:5]
componentes <- c("PC1", "PC2", "PC3", "PC4", "PC5")
componentes.plots <- list()
for (i in 1:(length(componentes) - 1))  {
grafico <- ggplot(df_pca_scores, aes_string(x =componentes[i], y = componentes[i+1], color = df$metastasisnosi))+geom_point(size = 3)
componentes.plots[[i]] <- grafico
}
grid.arrange(grobs = componentes.plots, nrow = 2)
# creo un tibble para guardar datos del test de normalidad y lo convierto a data frame
norm_test_1 <- tibble(`Variable` = rep(NA, 46),
`Test utilizado` = rep("Test de Shapiro-Wilk", 46),
`Valor p` = rep(NA, 46),
`Interp` = rep(NA, 46)) %>% as.data.frame()
# bucle para rellenar tabla de resultado
for (i in 1:length(df_genes)) {
norm_test_1[i,1] <- colnames(df_genes)[[i]] # rellenar col 1 de tabla 1
norm_test_1[i,2] <- "Shapiro-Wilk" # rellenar col 2 de tabla 1
shapiro_result <- shapiro.test(df_genes[[i]]) # calculo el test y lo guardo en shapiro_result
pvalue = shapiro_result$p.value # guardo el pvalue en otra variable
# if-else para rellenar col 3
if (pvalue < 0.001) {pvalue_f <- signif(pvalue, digits = 3)} # redondear pvalue a 3 decimales en SNotation
else  {pvalue_f <- round(pvalue, 3)} # expresar pvalue redondeado a 3 caracteres
norm_test_1[i, 3] <- as.numeric(pvalue_f)
# rellenar col 4 en función de pvalor
if (pvalue < 0.05) {norm_test_1[i, 4] <- "D. NO normal"}
else {norm_test_1[i, 4] <- "D. NORMAL"}
}
# castear norm_test_1$Interpretacion como tipo factor para ver summary()
summary(as.factor(norm_test_1$Interp))
# Con un bucle for
for (i in 1:length(df_pca_scores)) {
# guardo terciles 1 y 2 en variables
t1 = quantile(df_pca_scores[[i]], probs=c(1/3))
t2 = quantile(df_pca_scores[[i]], probs=c(2/3))
# defino nombre de nueva columna
column_name = paste0("T", colnames(df_pca_scores)[[i]])
# genero
df_pca_scores[[column_name]] = as.factor(cut(df_pca_scores[[i]], c(-Inf, t1, t2, Inf), labels = c("t1", "t2", "t3")))
}
summary(df_pca_scores)# check result
# Construir tabla descriptiva
#############################
df_d_pca <- cbind(df_genes, df_pca_scores) # concatenamos df de expresión génica y df con las pcs
reset_gtsummary_theme() # resetear opciones de tema para gtsummary
theme_gtsummary_compact() # usar tema `Compact` en gtsummary
# Defino vectors con nombres de vars
gene_varnames <- c(names(df_genes))
pca_varnames <- names(df_pca_scores)
d_pca_varnames <- names(df_d_pca)
strata_vars <- c("PC1", "PC2", "PC3", "PC4", "PC5")
by_vars <- c("TPC1", "TPC2", "TPC3", "TPC4", "TPC5")
result_list <- map2(strata_vars, by_vars, ~ {
df_d_pca %>%
# Seleccionar solo las columnas relevantes: x es la PC, y es su col de terciles
dplyr::select(all_of(gene_varnames), .y) %>%
# Construimos tabla con tbl_summary
tbl_summary(by = .y, # estratificar en función de 3-iles
statistic = all_continuous() ~ "{median} ({p25}, {p75})", #mediana + IQR
# digitos en scientific notation
digits = all_continuous() ~ function(x) format(x, digits = 2, scientific = TRUE),
missing = "no") %>%  # excluir NAs
# Prueba de Kruskal-Wallis solo a vars de expresión génica
add_p(test = all_continuous() ~ "kruskal.test", include = all_of(gene_varnames)) %>%
# añadir corrección de pvalue para disminuir falsos positivos
add_q(method = "bonferroni", pvalue_fun = NULL, quiet = NULL) %>%
bold_p(t = 0.05, q = TRUE) #destacar pvalues significativos en negrita
})
# Convertir cada tabla en result_list a gt
gt_tables <- map(result_list, as_gt)
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = FALSE)
rm(list=ls()) #resetear WEnv
#thisfile_path <- file.choose() #elegir
#wd_path <- sub("/[^/]+$", "", thisfile_path) #ruta de este archivo hasta el último "/" (excluyendo nombre del archivo))
#setwd(wd_path) #setear wd_path como WD
set.seed(1999) #random seed
library(tidyverse) #ggplot2, dplyr, tidyr, ggpubr, readr...
library(stats) #ops. básicas de estadística
library(factoextra) #
library(pheatmap) #heatmaps
library(gtsummary) #tabla est.descriptiva
library(gt) #convertir dfs en tablas con estilo gtsummary
library(MASS)
library(glmnet)
library(ggplot2)
library(gridExtra)
library(jtools)
library(car)
df <- read.csv("1_data/Dataset expresión genes.csv") # dataframe con todas las variables
#na.strings = este arg. dice si hay alguna cadena de texto q queramos importar como NA
df_genes <- df %>% dplyr::select(starts_with("AQ_")) # df solo de los genes
df_nogenes <- df %>% dplyr::select(-starts_with("AQ_")) # df solo de los genes
pca.result <- prcomp(df_genes, center = TRUE, scale = TRUE )
eigenvalues <- get_eigenvalue(pca.result) %>% round(., 2) # sacar eigenvalues y representar las cols en formato numérico estándar con 2 decimales
tabla_pca_r2 <- eigenvalues %>%
tibble::rownames_to_column(var="Componente") %>% # guardar nombres de PCs como columna
dplyr::select(Componente, variance.percent) %>% # generar tabla PCA componentes y R2
dplyr::rename(R2 = variance.percent)
#guardar esta tabla
#gtsave(gt(tabla_pca_r2), filename = "4_tables/Tabla 1 - PCA Componentes R2.html") # guardar html
head(eigenvalues) # ver caract. de primeras dimensiones
fviz_eig(pca.result, addlabels = TRUE)
fviz_pca_var(pca.result, col.var = "cos2", gradient.cols = c("blue","yellow", "red"), repel = TRUE, axes = c(1,2),
title = "Cos2 de variables en PC1 y PC2")
kmeans <- kmeans(t(df_genes), centers = 2)
clusters <- list()
for (i in 1:4) {
cluster.plot <- fviz_pca_var(
pca.result, col.var = kmeans$cluster, gradient.cols = c("blue","green", "red"),
axes = c(i,i+1), legend.title ="Clusterizacion", repel = TRUE)
clusters[[i]] <- cluster.plot
}
todos.clusters <- grid.arrange(grobs = clusters, nrow = 2)
todos.clusters
graficos <- list()
for (i in 1:5) {
grafico <- fviz_contrib(pca.result, choice ="var", axes = i, top = 5)
graficos[[i]] <- grafico
}
graficos_varianza <- grid.arrange(grobs = graficos, nrow = 3)
pca_loadings <- as.data.frame(pca.result$rotation) #los guardamos en un df
pca_loadings <- pca_loadings %>%
tibble::rownames_to_column(var="Gene") # gene names a columna (para no perderlos)
# los guardo en un objeto aparte para exportar con gt (ya que el formateo en scientific notation los conveirte en tipo chr.)
pca_loadings_exp <- pca_loadings %>% mutate(across(.cols = -Gene, # para toda cols excp Gene
~ ifelse(. < 0.1, sprintf("%.1e", .), sprintf("%.2f", .)))) # redondeamos a 1 decimal y escribimos en notación científica si son < 0.1, también con un decimal
# guardamos el df como objeto gt y exportamos para visualizar en Anexo
gtsave(gt(pca_loadings_exp), filename = "Tabla 2 - PCA Cargas.html") # guardar html
kmeans2 <- kmeans(df_genes, centers = 3)
fviz_cluster(kmeans2, df_genes)
fviz_pca_ind(pca.result, col.ind = "cos2", gradient.cols = c("blue","yellow", "red"), repel = TRUE)
df$metastasisnosi <- as.factor(ifelse( df$extension == "metastasico", "metastasis", "no_metastasis"))
df_pca_scores <- as.data.frame(pca.result$x)
df_pca_scores <- df_pca_scores[1:5]
componentes <- c("PC1", "PC2", "PC3", "PC4", "PC5")
componentes.plots <- list()
for (i in 1:(length(componentes) - 1))  {
grafico <- ggplot(df_pca_scores, aes_string(x =componentes[i], y = componentes[i+1], color = df$metastasisnosi))+geom_point(size = 3)
componentes.plots[[i]] <- grafico
}
grid.arrange(grobs = componentes.plots, nrow = 2)
# creo un tibble para guardar datos del test de normalidad y lo convierto a data frame
norm_test_1 <- tibble(`Variable` = rep(NA, 46),
`Test utilizado` = rep("Test de Shapiro-Wilk", 46),
`Valor p` = rep(NA, 46),
`Interp` = rep(NA, 46)) %>% as.data.frame()
# bucle para rellenar tabla de resultado
for (i in 1:length(df_genes)) {
norm_test_1[i,1] <- colnames(df_genes)[[i]] # rellenar col 1 de tabla 1
norm_test_1[i,2] <- "Shapiro-Wilk" # rellenar col 2 de tabla 1
shapiro_result <- shapiro.test(df_genes[[i]]) # calculo el test y lo guardo en shapiro_result
pvalue = shapiro_result$p.value # guardo el pvalue en otra variable
# if-else para rellenar col 3
if (pvalue < 0.001) {pvalue_f <- signif(pvalue, digits = 3)} # redondear pvalue a 3 decimales en SNotation
else  {pvalue_f <- round(pvalue, 3)} # expresar pvalue redondeado a 3 caracteres
norm_test_1[i, 3] <- as.numeric(pvalue_f)
# rellenar col 4 en función de pvalor
if (pvalue < 0.05) {norm_test_1[i, 4] <- "D. NO normal"}
else {norm_test_1[i, 4] <- "D. NORMAL"}
}
# castear norm_test_1$Interpretacion como tipo factor para ver summary()
summary(as.factor(norm_test_1$Interp))
# Con un bucle for
for (i in 1:length(df_pca_scores)) {
# guardo terciles 1 y 2 en variables
t1 = quantile(df_pca_scores[[i]], probs=c(1/3))
t2 = quantile(df_pca_scores[[i]], probs=c(2/3))
# defino nombre de nueva columna
column_name = paste0("T", colnames(df_pca_scores)[[i]])
# genero
df_pca_scores[[column_name]] = as.factor(cut(df_pca_scores[[i]], c(-Inf, t1, t2, Inf), labels = c("t1", "t2", "t3")))
}
summary(df_pca_scores)# check result
# Construir tabla descriptiva
#############################
df_d_pca <- cbind(df_genes, df_pca_scores) # concatenamos df de expresión génica y df con las pcs
reset_gtsummary_theme() # resetear opciones de tema para gtsummary
theme_gtsummary_compact() # usar tema `Compact` en gtsummary
# Defino vectors con nombres de vars
gene_varnames <- c(names(df_genes))
pca_varnames <- names(df_pca_scores)
d_pca_varnames <- names(df_d_pca)
strata_vars <- c("PC1", "PC2", "PC3", "PC4", "PC5")
by_vars <- c("TPC1", "TPC2", "TPC3", "TPC4", "TPC5")
result_list <- map2(strata_vars, by_vars, ~ {
df_d_pca %>%
# Seleccionar solo las columnas relevantes: x es la PC, y es su col de terciles
dplyr::select(all_of(gene_varnames), .y) %>%
# Construimos tabla con tbl_summary
tbl_summary(by = .y, # estratificar en función de 3-iles
statistic = all_continuous() ~ "{median} ({p25}, {p75})", #mediana + IQR
# digitos en scientific notation
digits = all_continuous() ~ function(x) format(x, digits = 2, scientific = TRUE),
missing = "no") %>%  # excluir NAs
# Prueba de Kruskal-Wallis solo a vars de expresión génica
add_p(test = all_continuous() ~ "kruskal.test", include = all_of(gene_varnames)) %>%
# añadir corrección de pvalue para disminuir falsos positivos
add_q(method = "bonferroni", pvalue_fun = NULL, quiet = NULL) %>%
bold_p(t = 0.05, q = TRUE) #destacar pvalues significativos en negrita
})
# Convertir cada tabla en result_list a gt
gt_tables <- map(result_list, as_gt)
# Imprimir cada tabla individualmente (guardadas en documento adjunto)
walk(gt_tables, print) No ejecutar en el html
# Construir tabla descriptiva
#############################
df_d_pca <- cbind(df_genes, df_pca_scores) # concatenamos df de expresión génica y df con las pcs
reset_gtsummary_theme() # resetear opciones de tema para gtsummary
theme_gtsummary_compact() # usar tema `Compact` en gtsummary
# Defino vectors con nombres de vars
gene_varnames <- c(names(df_genes))
pca_varnames <- names(df_pca_scores)
d_pca_varnames <- names(df_d_pca)
strata_vars <- c("PC1", "PC2", "PC3", "PC4", "PC5")
by_vars <- c("TPC1", "TPC2", "TPC3", "TPC4", "TPC5")
result_list <- map2(strata_vars, by_vars, ~ {
df_d_pca %>%
# Seleccionar solo las columnas relevantes: x es la PC, y es su col de terciles
dplyr::select(all_of(gene_varnames), .y) %>%
# Construimos tabla con tbl_summary
tbl_summary(by = .y, # estratificar en función de 3-iles
statistic = all_continuous() ~ "{median} ({p25}, {p75})", #mediana + IQR
# digitos en scientific notation
digits = all_continuous() ~ function(x) format(x, digits = 2, scientific = TRUE),
missing = "no") %>%  # excluir NAs
# Prueba de Kruskal-Wallis solo a vars de expresión génica
add_p(test = all_continuous() ~ "kruskal.test", include = all_of(gene_varnames)) %>%
# añadir corrección de pvalue para disminuir falsos positivos
add_q(method = "bonferroni", pvalue_fun = NULL, quiet = NULL) %>%
bold_p(t = 0.05, q = TRUE) #destacar pvalues significativos en negrita
})
# Convertir cada tabla en result_list a gt
gt_tables <- map(result_list, as_gt)
# Imprimir cada tabla individualmente (guardadas en documento adjunto)
walk(gt_tables, print) #No ejecutar en el html
# Guardar cada tabla individualmente como .html
walk2(gt_tables, seq_along(gt_tables), ~ gtsave(.x, filename = paste0("Tabla 3 - Descriptiva PC", .y, ".html"))) No ejecutar en el html
# Construir tabla descriptiva
#############################
df_d_pca <- cbind(df_genes, df_pca_scores) # concatenamos df de expresión génica y df con las pcs
reset_gtsummary_theme() # resetear opciones de tema para gtsummary
theme_gtsummary_compact() # usar tema `Compact` en gtsummary
# Defino vectors con nombres de vars
gene_varnames <- c(names(df_genes))
pca_varnames <- names(df_pca_scores)
d_pca_varnames <- names(df_d_pca)
strata_vars <- c("PC1", "PC2", "PC3", "PC4", "PC5")
by_vars <- c("TPC1", "TPC2", "TPC3", "TPC4", "TPC5")
result_list <- map2(strata_vars, by_vars, ~ {
df_d_pca %>%
# Seleccionar solo las columnas relevantes: x es la PC, y es su col de terciles
dplyr::select(all_of(gene_varnames), .y) %>%
# Construimos tabla con tbl_summary
tbl_summary(by = .y, # estratificar en función de 3-iles
statistic = all_continuous() ~ "{median} ({p25}, {p75})", #mediana + IQR
# digitos en scientific notation
digits = all_continuous() ~ function(x) format(x, digits = 2, scientific = TRUE),
missing = "no") %>%  # excluir NAs
# Prueba de Kruskal-Wallis solo a vars de expresión génica
add_p(test = all_continuous() ~ "kruskal.test", include = all_of(gene_varnames)) %>%
# añadir corrección de pvalue para disminuir falsos positivos
add_q(method = "bonferroni", pvalue_fun = NULL, quiet = NULL) %>%
bold_p(t = 0.05, q = TRUE) #destacar pvalues significativos en negrita
})
# Convertir cada tabla en result_list a gt
gt_tables <- map(result_list, as_gt)
# Imprimir cada tabla individualmente (guardadas en documento adjunto)
walk(gt_tables, print) #No ejecutar en el html
# Guardar cada tabla individualmente como .html
walk2(gt_tables, seq_along(gt_tables), ~ gtsave(.x, filename = paste0("Tabla 3 - Descriptiva PC", .y, ".html"))) #No ejecutar en el html
# las variables factor están en tipo character, tengo que convertirlas a numérico pq glmnet no admite tipo factor
# casteo a numérico variables char
df_nogenes <- df %>% dplyr::select(-starts_with("AQ_"), -X, -id, -extension) # df de vars q no son genes
df_char <- df_nogenes[ ,sapply(df_nogenes, is.character)]# guardamos las vars factor en un vector lógico
df_char$antiemesis <- as.character(ifelse(df$corticoides=="antiemesis", "1", "0"))
df_char$corticoides <- as.character(ifelse(df$corticoides=="si", "1", "0"))
df_nochar <- df_nogenes[, sapply(df_nogenes, is.numeric)]
df_nochar <- as.data.frame(scale(df_nochar, center=TRUE, scale=TRUE))
# convierto variables tipo char a factor y luego a numeros para codificarlas de manera que glmnet las entienda
for (i in colnames(df_char)) {
df_char[[i]] <-as.numeric(as.factor(df_char[[i]]))
}
# y concateno df_char, df_nochar y df5 pcs en df_lasso
df_regularizacion <- cbind(df_char, df_nochar)
# ahora tb dejo bien formateada la variable respuesta
df$metastasis = as.factor(as.numeric(ifelse(df$extension == "metastasico", 1, 0)))
# defino variables para df_lasso
cols = c(colnames(df_regularizacion))
x <- df_regularizacion[, cols]
y <- df$metastasis
# convertir a matriz para incluir interacciones entre todas las variables
formula <- as.formula(paste("y ~", paste(names(x), collapse = " * "))) # Crear una matriz de diseño con interacciones entre todas las variables
set.seed(1456)
# construimos un grid para encontrar lambda óptimo (el que minimice el error predicho por el modelo vs el dato real)
grid <- 10^seq(1.5, -1.5, length=100)
# y aplicamos ridge (alpha=0)
ridge <- glmnet(x, y, alpha=0, lambda=grid, family="binomial")
dim(coef(ridge))
head(coef(ridge))
plot(ridge, xvar="lambda", label=TRUE) #log lambda plot > nos permite hacernos una idea de por dónde estará el lambda óptimo
x_matrix <- as.matrix(x)
y_matrix <- as.matrix(y)
# hago un m
#modelo de cross validation
ridge_cv <- cv.glmnet(x_matrix, y_matrix, alpha=0, lambda=grid, family="binomial")
lambda_min <- ridge_cv$lambda.min # este es el lambda que menor error nos da para el modelo, me lo guardo en un objeto
# y lo uso para generar modelo de ridge
ridge_cv <- glmnet(x_matrix, y_matrix, alpha=0, lambda = lambda_min, family="binomial")
coefs <- as.data.frame(as.matrix(coef(ridge_cv))) %>% tibble::rownames_to_column(var="Var")#guardar coefs en df
coefs <- coefs[order(-coefs$s0), ] # Ordenar los coeficientes de mayor a menor
head(coefs, 10) # ver los 10 primeros más significativos
set.seed(1456)
grid <- 10^seq(-4,1, lenght=100)
lasso <- glmnet(x, y, alpha=1, lambda=grid, family="binomial")
dim(coef(lasso))
print(coef(lasso))
plot(lasso, xvar="lambda", label=TRUE) #log lambda plot
lambda_min <- lasso$lambda.min
lambda_1se <- lasso$lambda.1se
lasso_cv <- glmnet(x_matrix, y_matrix, alpha=1, lambda = lambda_1se, family="binomial")
coefs <- as.data.frame(as.matrix(coef(lasso_cv))) %>% tibble::rownames_to_column(var="Var")#guardar coefs en df
# Ordenar los coeficientes de mayor a menor y filtrar los que sean 0
coefs <- coefs[order(-coefs$s0), ] %>% filter(`s0`!=0.000000000000)
head(coefs, 10) # ver los 10 primeros más significativos
# Cargar librerías necesarias
library(broom)
library(stringr)
# Esto te da un dataframe con los términos, estimaciones, etc.
df_ors <- as.data.frame(tidy(modelo_regresion3, exponentiate = TRUE, conf.int=TRUE))
# Eliminar las variables específicas de la fórmula
reg_vars_modificadas_2 <- c(colnames(df_pca_scores[6:10]))
# Deseleccionar del df
df_regresion_3 <- df_regresion[, reg_vars_modificadas_2]
df_regresion <- cbind(df_regresion, df_pca_scores[6:10]) #añadimos al dataframe de regresion los terciles de las PCs
cat("Lambda min:", lambda_min, "\nLambda + 1SE:", lambda_1se)
plot(lasso)# este gráfico nos enseña las variables retenidas para los distintos labmda
set.seed(1456)
seq_alpha <- seq(0.01,0.99,by=0.01) # limitamos el rango para no hacer ni ridge ni lasso
grid <- 10^seq(-3, 3, length=100)
best_alpha <- NULL
best_lambda <- NULL
min_error <- Inf
# encontrar el mejor alpha
for (alpha in seq_alpha) {
enet_cv <- cv.glmnet(x_matrix, y_matrix, alpha=alpha, lambda=grid, family="binomial")
# Obtener valor de lambda óptimo elegido automáticamente
lambda_min<-enet_cv$lambda.min
#Obtener el error de validación cruzada mínimo
cv_error <- min(enet_cv$cvm)
#Actualizar el mejor alpha y lambda si se encuentra un error de cv menor
if (cv_error < min_error) {
min_error <- cv_error
best_alpha <- alpha
best_lambda <- lambda_min
}}
# Imprimir el mejor alpha y lambda encontrados tras el bucle
cat("Mejor alpha:", best_alpha, "\n")
cat("Mejor lambda:", best_lambda, "\n")
grid <- 10^seq(0, -2, length=100)
# hago un modelo de cross validation
enet_cv <- cv.glmnet(x_matrix, y_matrix, alpha=best_alpha, lambda=grid, family="binomial")
plot(enet_cv)
lambda_1se <- enet_cv$lambda.1se
lambda_1se
enet_cv <- glmnet(x_matrix, y_matrix, alpha=best_alpha, lambda=10^-1.3, family="binomial")
coefs_enet <- as.data.frame(as.matrix(coef(enet_cv))) %>% tibble::rownames_to_column(var="Var")#guardar coefs en df
# ordenamos de manera descendente y filtramos los == 0
coefs_enet <- coefs_enet[order(-coefs_enet$s0), ] %>% filter(`s0`!=0.000000000000) %>% # quitamos las == 0
filter(Var != "(Intercept)") # quitamos el intercept
coefs_enet
reg_vars <- c(coefs_enet$Var) # Guardamos variables de elasticnet en vectror
df_regresion <- df_regularizacion %>% dplyr::select(all_of(reg_vars <- c(coefs_enet$Var))) # creamos df_regresion (vacío)
#Tambien hay que añadir la variable categorica
df_regresion$metastasis <- as.factor(df$metastasis)
# Convertimos las variables en tipo factor
for (var in reg_vars) {
if (var %in% colnames(df_char)) { # castear solo las que esten en df_char, que son las tipo factor
df_regresion[[var]] <- as.factor(df_regresion[[var]])
}}
df_regresion <- cbind(df_regresion, df_pca_scores[6:10]) #añadimos al dataframe de regresion los terciles de las PCs
reg_vars <- colnames(df_regresion) #guardo colnames en un vector
reg_vars_x <- setdiff(reg_vars, "metastasis")
formula <- as.formula(paste("metastasis ~", paste(reg_vars_x, collapse = "+")))
modelo_regresion <- glm(formula, data = df_regresion, family = "binomial")
cat("ODDS RATIOS\n")
exp(coef(modelo_regresion)) #OR
cat("\nICs\n")
head(exp(confint(modelo_regresion)), 10) # ver primeros 10 ICs
cat("\nMODEL SUMMARY\n")
rl_summary <- summ(modelo_regresion) #pvalores
rl_summary$coeftable
#Comprobamos colinealidad
vif <- as.data.frame(vif(modelo_regresion))
vif <- vif[order(-vif$`GVIF^(1/(2*Df))`), ]
cat("MODELO 1")
head(vif, 10)
#habria que quitar aquellas variables con un VIF mayor de 5:
variables_a_eliminar <- c("TPC1", "neumopatia", "neuropatia", "corticoides", "secrecion", "dolor_abdo", "chol", "hierro", "igN", "cpk")
# Eliminar las variables específicas de la fórmula
reg_vars_modificadas <- setdiff(reg_vars_x, variables_a_eliminar)
# Deseleccionar del df
df_regresion_2 <- df_regresion[, reg_vars_modificadas]
# Crear la nueva fórmula con las variables modificadas
formula_modificada <- as.formula(paste("metastasis ~", paste(reg_vars_modificadas, collapse = "+")))
modelo_regresion2 <- glm(formula_modificada, data = df_regresion, family = "binomial")
# Ver resultados
cat("ODDS RATIOS\n")
exp(coef(modelo_regresion2)) #OR
cat("\nICs\n")
round(exp(confint(modelo_regresion2)), 2) # ver primeros 10 ICs
#cat("\nMODEL SUMMARY\n")
#rl_summary_2 <- summ(modelo_regresion2) #pvalores
#rl_summary_2$coeftable
cat("\nVIF\n")
vif2 <- as.data.frame(vif(modelo_regresion2))
vif2 <- vif2[order(-vif2$`GVIF^(1/(2*Df))`), ]
head(vif2, 10)
# Eliminar las variables específicas de la fórmula
reg_vars_modificadas_2 <- c(colnames(df_pca_scores[6:10]))
# Deseleccionar del df
df_regresion_3 <- df_regresion[, reg_vars_modificadas_2]
# Crear la nueva fórmula con las variables modificadas
formula_modificada_2 <- as.formula(paste("metastasis ~", paste(reg_vars_modificadas_2, collapse = "+")))
modelo_regresion3 <- glm(formula_modificada_2, data = df_regresion, family = "binomial")
# Ver resultados
cat("ODDS RATIOS\n")
exp(coef(modelo_regresion3)) #OR
cat("\nICs\n")
round(exp(confint(modelo_regresion3)), 2) # ver primeros 10 ICs
#cat("\nMODEL SUMMARY\n")
#rl_summary_2 <- summ(modelo_regresion2) #pvalores
#rl_summary_2$coeftable
cat("\nVIF\n")
vif3 <- as.data.frame(vif(modelo_regresion3))
vif3 <- vif3[order(-vif3$`GVIF^(1/(2*Df))`), ]
vif3
# Cargar librerías necesarias
library(broom)
library(stringr)
# Esto te da un dataframe con los términos, estimaciones, etc.
df_ors <- as.data.frame(tidy(modelo_regresion3, exponentiate = TRUE, conf.int=TRUE))
# separar df_ors$term en PC y Tercil
matches <- stringr::str_match(df_ors$term, "^(?:T)(PC\\d)(t\\d)$")
df_ors[c("Variable", "Tercil")] <- matches[,2:3]
df_ors[1, 8:9] = c("PC5", "t1")
# repetir fila del intercept 4 veces (5 copias, 5 PCs)
copias_pcs <- df_ors[rep(1,4), ]
copias_pcs[1:4, 8] = c("PC1", "PC2", "PC3", "PC4")
df_ors <- rbind(copias_pcs, df_ors)
# juntar df$estimate, df$conf.low y df$conf.high
df_ors$estimate <- as.character(round(df_ors$estimate, 2))
df_ors$conf.low <- as.character(round(df_ors$conf.low, 2))
df_ors$conf.high <- as.character(round(df_ors$conf.high, 2))
df_ors$OR = str_c(df_ors$estimate, " (",
df_ors$conf.low, " - ",
df_ors$conf.high, ")")
# eliminar variables que no quiero
vars_2_erase <- c("std.error", "statistic", "estimate", "conf.low", "conf.high", "term")
df_ors <- df_ors %>% dplyr::select(-all_of(vars_2_erase))
# pasar datos a formato wide
df_wide <- df_ors %>%
pivot_wider(names_from = Tercil,
values_from = c(OR, p.value),
names_sep = " ") %>%
as.data.frame()
# definir valores de "Variable"
df_wide$Variable = c("PC 1", "PC 2", "PC 3", "PC 4", "PC 5")
# Ordenar variables
df_wide <- df_wide %>% dplyr::select("Variable",
"OR t1", "p.value t1",
"OR t2", "p.value t2",
"OR t3", "p.value t3")
# redondear vaor de pvalue
df_wide$`p.value t1` = round(df_wide$`p.value t1`, 2)
df_wide$`p.value t2` = round(df_wide$`p.value t2`, 2)
df_wide$`p.value t3` = round(df_wide$`p.value t3`, 2)
# Ver el resultado
library(gt)
gt(df_wide)
gtsave(gt(df_wide), filename = "Tabla 4 - Tabla de regresión Logística.html")#guardar html
